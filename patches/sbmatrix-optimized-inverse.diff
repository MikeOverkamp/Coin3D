From: Peder Blekken <pederb@sim.no>
Subject: matrix inverse
To: Morten Eriksen <mortene@sim.no>
Date: Tue, 16 Jan 2001 13:06:23 +0100

To algoritmer (en for affine og en for non-affine). 

Det maa vel lages en regresjonstest foer denne blir committet.

Peder


[2. text/plain; inverse.diff]

Index: src/base/SbMatrix.cpp
===================================================================
RCS file: /export/cvsroot/Coin/src/base/SbMatrix.cpp,v
retrieving revision 1.29
diff -u -r1.29 SbMatrix.cpp
--- src/base/SbMatrix.cpp	2001/01/14 20:02:59	1.29
+++ src/base/SbMatrix.cpp	2001/01/16 12:03:41
@@ -301,6 +301,180 @@
 SbMatrix
 SbMatrix::inverse(void) const
 {
+#if 1 // new optimized version
+
+  SbMatrix result;
+
+  // use local pointers for speed
+  float (*dst)[4];
+  dst = (float (*)[4]) result.matrix[0];
+  float (*src)[4];
+  src = (float (*)[4]) this->matrix[0];
+
+  // check for affine matrix (common case)
+  if (src[0][3] == 0.0f && src[1][3] == 0.0f &&
+      src[2][3] == 0.0f && src[3][3] == 1.0f) {
+
+    // check for identity matrix (we already checked last row)
+    if (src[0][0] == 1.0f && 
+        src[0][1] == 0.0f && 
+        src[0][2] == 0.0f &&
+        src[1][0] == 0.0f &&
+        src[1][1] == 1.0f &&
+        src[1][2] == 0.0f &&
+        src[2][0] == 0.0f &&
+        src[2][1] == 0.0f &&
+        src[2][2] == 1.0f) return SbMatrix::identity();
+    
+    // More or less directly from:
+    // Kevin Wu, "Fast Matrix Inversion",  Graphics Gems II
+    float det_1;
+    float pos, neg, temp;
+
+#define ACCUMULATE     \
+    if (temp >= 0.0f)  \
+      pos += temp;     \
+    else               \
+      neg += temp
+
+    /*
+     * Calculate the determinant of submatrix A and determine if the
+     * the matrix is singular as limited by floating-point data 
+     * representation.
+     */
+    pos = neg = 0.0f;
+    temp =  src[0][0] * src[1][1] * src[2][2];
+    ACCUMULATE;
+    temp =  src[0][1] * src[1][2] * src[2][0];
+    ACCUMULATE;
+    temp =  src[0][2] * src[1][0] * src[2][1];
+    ACCUMULATE;
+    temp = -src[0][2] * src[1][1] * src[2][0];
+    ACCUMULATE;
+    temp = -src[0][1] * src[1][0] * src[2][2];
+    ACCUMULATE;
+    temp = -src[0][0] * src[1][2] * src[2][1];
+    ACCUMULATE;
+    det_1 = pos + neg;
+
+#undef ACCUMULATE
+
+    /* Is the submatrix A singular? */
+    if ((det_1 == 0.0f) || (SbAbs(det_1 / (pos - neg)) < FLT_EPSILON)) {
+      /* Matrix M has no inverse */
+#if COIN_DEBUG
+      SoDebugError::postWarning("SbMatrix::inverse",
+                                "Matrix is singular.");
+#endif // COIN_DEBUG
+      return *this;
+    }
+    else {
+        /* Calculate inverse(A) = adj(A) / det(A) */
+        det_1 = 1.0f / det_1;
+        dst[0][0] = (src[1][1] * src[2][2] -
+                     src[1][2] * src[2][1]) * det_1;
+        dst[1][0] = - (src[1][0] * src[2][2] -
+                       src[1][2] * src[2][0]) * det_1;
+        dst[2][0] = (src[1][0] * src[2][1] -
+                     src[1][1] * src[2][0]) * det_1;
+        dst[0][1] = - (src[0][1] * src[2][2] -
+                       src[0][2] * src[2][1]) * det_1;
+        dst[1][1] = (src[0][0] * src[2][2] -
+                     src[0][2] * src[2][0]) * det_1;
+        dst[2][1] = - (src[0][0] * src[2][1] -
+                       src[0][1] * src[2][0]) * det_1;
+        dst[0][2] =  (src[0][1] * src[1][2] -
+                      src[0][2] * src[1][1]) * det_1;
+        dst[1][2] = - (src[0][0] * src[1][2] -
+                       src[0][2] * src[1][0]) * det_1;
+        dst[2][2] =  (src[0][0] * src[1][1] -
+                      src[0][1] * src[1][0]) * det_1;
+
+        /* Calculate -C * inverse(A) */
+        dst[3][0] = - (src[3][0] * dst[0][0] +
+                       src[3][1] * dst[1][0] +
+                       src[3][2] * dst[2][0]);
+        dst[3][1] = - (src[3][0] * dst[0][1] +
+                       src[3][1] * dst[1][1] +
+                       src[3][2] * dst[2][1]);
+        dst[3][2] = - (src[3][0] * dst[0][2] +
+                       src[3][1] * dst[1][2] +
+                       src[3][2] * dst[2][2]);
+
+        /* Fill in last column */
+        dst[0][3] = dst[1][3] = dst[2][3] = 0.0f;
+        dst[3][3] = 1.0f;
+    }
+  }
+  else { // non-affine matrix
+    float max, sum, tmp, inv_pivot;
+    int p[4];
+    int i, j, k;
+
+    // algorithm from: Schwarz, "Numerische Mathematik"
+    result = *this;
+
+    for (k = 0; k < 4; k++) { 
+      max = 0.0f;
+      p[k] = 0;
+      
+      for (i = k; i < 4; i++) { 
+        sum = 0.0f;
+        for (j = k; j < 4; j++)
+          sum += SbAbs(dst[i][j]);
+        if (sum > 0.0f) {
+          tmp = SbAbs(dst[i][k]) / sum;
+          if (tmp > max) { 
+            max = tmp;  
+            p[k] = i;
+          }
+        }
+      }
+      
+      if (max == 0.0f) {
+#if COIN_DEBUG
+        SoDebugError::postWarning("SbMatrix::inverse",
+                                  "Matrix is singular.");
+#endif // COIN_DEBUG
+        return *this;
+      }
+      
+      if (p[k] != k) {
+        for (j = 0; j < 4; j++) {
+          tmp = dst[k][j];  
+          dst[k][j] = dst[p[k]][j];  
+          dst[p[k]][j] = tmp;
+        }
+      }
+      
+      inv_pivot = 1.0f / dst[k][k];
+      for (j = 0; j < 4; j++) {
+        if (j != k) {
+          dst[k][j] = - dst[k][j] * inv_pivot;
+          for (i = 0; i < 4; i++) {
+            if (i != k) dst[i][j] += dst[i][k] * dst[k][j];
+          }
+        }
+      }
+      
+      for (i = 0; i < 4; i++) dst[i][k] *= inv_pivot;
+      dst[k][k] = inv_pivot;
+    }
+    
+    for (k = 2; k >= 0; k--) {
+      if (p[k] != k) {
+        for (i = 0; i < 4; i++) {
+          tmp = dst[i][k];
+          dst[i][k] = dst[i][p[k]]; 
+          dst[i][p[k]] = tmp;
+        }
+      }
+    }
+  }
+  return result;
+    
+#else  // old unoptimized version
+
   float det = this->det4();
 #if COIN_DEBUG
   if (det == 0.0f) {
@@ -333,6 +507,8 @@
 
   result /= det;
   return result;
+
+#endif // old unoptimized version
 }
 
 /*!

