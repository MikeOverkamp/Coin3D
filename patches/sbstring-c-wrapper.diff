This patch rewrites the SbString class to be a wrapper around a
pure C implementation of the same functionality.

Installing it changes the Coin ABI heavily - all dependencies
has to be recompiled.

You have to change the build setup yourself - I have other changes
in mine that makes producing good diffs for this a hassle.  Fix
these files if you apply this patch.

  src/base/all.cpp
  src/base/Makefile.am
  include/Inventor/C/base/Makefile.am

The patch also extends the SbString class with the following
functions:

  int compareSubString(const char * text, int offset = 0);
  void apply(char (*func)(char input));

Former can optimize some code (see "So"-prefix comparison in
SoType::fromName() for an example of lots of instantiations for
some really trivial stuff), and the latter is a wishlist
item from Peder.

Anyways, the implementation seems to be quite bugfree now.

  Lars J


UPDATE 2002-05-22 mortene: SbString includes two new methods find()
and findAll() now which are written in C++. These should eventually be
converted to pure C aswell. See the FIXME at the top of the
SbString.cpp file.


Index: include/Inventor/SbString.h
===================================================================
RCS file: /export/cvsroot/Coin/include/Inventor/SbString.h,v
retrieving revision 1.20
diff -u -r1.20 SbString.h
--- include/Inventor/SbString.h	22 May 2002 07:14:17 -0000	1.20
+++ include/Inventor/SbString.h	24 May 2002 21:20:46 -0000
@@ -5,7 +5,7 @@
  *
  *  This file is part of the Coin 3D visualization library.
  *  Copyright (C) 1998-2001 by Systems in Motion.  All rights reserved.
- *  
+ *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU General Public License
  *  version 2 as published by the Free Software Foundation.  See the
@@ -25,69 +25,112 @@
 \**************************************************************************/
 
 #include <Inventor/system/inttypes.h>
-#include <Inventor/SbBasic.h>
+#include <Inventor/C/base/string.h>
 #include <Inventor/lists/SbIntList.h>
 
-#include <stdio.h>
 #include <stdarg.h>
 
-#define SB_STRING_STATIC_STORAGE_SIZE 128
-
-
 class COIN_DLL_API SbString {
 public:
-  SbString(void);
-  SbString(const char * str);
-  SbString(const char * str, int start, int end);
-  SbString(const SbString & str);
-  SbString(const int digits);
-  ~SbString();
-
-  uint32_t hash(void);
-  int getLength(void) const;
-  void makeEmpty(SbBool freeold = TRUE);
-  const char * getString(void) const;
-  SbString getSubString(int startidx, int endidx = -1) const;
-  void deleteSubString(int startidx, int endidx = -1);
+  SbString(void) { cc_string_construct(&this->str); }
+
+  SbString(const char * str)
+  { cc_string_construct(&this->str); cc_string_set_text(&this->str, str); }
+
+  SbString(const char * str, int start, int end)
+  { cc_string_construct(&this->str); cc_string_set_subtext(&this->str, str, start, end); }
+
+  SbString(const SbString & str)
+  { cc_string_construct(&this->str); cc_string_set_string(&this->str, &str.str); }
+
+  SbString(const int digits)
+  { cc_string_construct(&this->str); cc_string_set_integer(&this->str, digits); }
+
+  ~SbString() { cc_string_clean(&this->str); }
+
+  uint32_t hash(void) { return cc_string_hash(&this->str); }
+  static uint32_t hash(const char * s) { return cc_string_hash_text(s); }
+
+  int getLength(void) const { return cc_string_length(&this->str); }
+
+  void makeEmpty(SbBool freeold = TRUE)
+  {
+    if ( freeold ) cc_string_clear(&this->str);
+    else cc_string_clear_no_free(&this->str);
+  }
 
-  void addIntString(const int value);
+  const char * getString(void) const { return cc_string_get_text(&this->str); }
+
+  SbString getSubString(int startidx, int endidx = -1) const
+  {
+    SbString s;
+    cc_string_set_subtext(&s.str, cc_string_get_text(&this->str), startidx, endidx);
+    return s;
+  }
+  void deleteSubString(int startidx, int endidx = -1)
+  {
+    cc_string_remove_substring(&this->str, startidx, endidx);
+  }
+
+  void addIntString(const int value) { cc_string_append_integer(&this->str, value); }
+
+  char operator[](int index) const { return this->str.pointer[index]; }
+
+  SbString & operator=(const char * str)
+  { cc_string_set_text(&this->str, str); return *this; }
+  SbString & operator=(const SbString & str)
+  { cc_string_set_text(&this->str, str.str.pointer); return *this; }
+
+  SbString & operator+=(const char * str)
+  { cc_string_append_text(&this->str, str); return *this; }
+  SbString & operator+=(const SbString & str)
+  { cc_string_append_string(&this->str, &str.str); return *this; }
+  SbString & operator+=(const char c)
+  { cc_string_append_char(&this->str, c); return *this; }
+
+  int operator!(void) const { return ! cc_string_is(&this->str); }
+
+  int compareSubString(const char * text, int offset = 0) const
+  { return cc_string_compare_subtext(&this->str, text, offset); }
+
+  SbString & sprintf(const char * formatstr, ...)
+  {
+    va_list args; va_start(args, formatstr);
+    cc_string_vsprintf(&this->str, formatstr, args);
+    va_end(args); return *this;
+  }
+  SbString & vsprintf(const char * formatstr, va_list args)
+  { cc_string_vsprintf(&this->str, formatstr, args); return *this; }
+
+  void apply(char (*func)(char input)) { cc_string_apply(&this->str, func); }
 
   int find(const SbString & str) const;
   SbBool findAll(const SbString & str, SbIntList & found) const;
 
-  char operator [](int index) const;
-  SbString & operator = (const char * str);
-  SbString & operator = (const SbString & str);
-  SbString & operator += (const char * str);
-  SbString & operator += (const SbString & str);
-  int operator ! (void) const;
-  friend COIN_DLL_API int operator == (const SbString & str, const char * s);
-  friend COIN_DLL_API int operator == (const char * s, const SbString & str);
-  friend COIN_DLL_API int operator == (const SbString & str1, const SbString & str2);
-  friend COIN_DLL_API int operator != (const SbString & str, const char * s);
-  friend COIN_DLL_API int operator != (const char * s, const SbString & str);
-  friend COIN_DLL_API int operator != (const SbString & str1, const SbString & str2);
-  static uint32_t hash(const char * s);
-
-  SbString & operator += (const char c);
-  SbString & sprintf(const char * formatstr, ...);
-  SbString & vsprintf(const char * formatstr, va_list args);
-
-  void print(FILE * file = stdout) const;
+  friend int operator==(const SbString & str, const char * s);
+  friend int operator==(const char * s, const SbString & str);
+  friend int operator==(const SbString & str1, const SbString & str2);
+  friend int operator!=(const SbString & str, const char * s);
+  friend int operator!=(const char * s, const SbString & str);
+  friend int operator!=(const SbString & str1, const SbString & str2);
 
 private:
-  char * sstring;
-  int storagesize;
-  char staticstorage[SB_STRING_STATIC_STORAGE_SIZE];
-  void expand(int additional);
+  struct cc_string str;
 };
 
-COIN_DLL_API int operator == (const SbString & str, const char * s);
-COIN_DLL_API int operator == (const char * s, const SbString & str);
-COIN_DLL_API int operator == (const SbString & str1, const SbString & str2);
-COIN_DLL_API int operator != (const SbString & str, const char * s);
-COIN_DLL_API int operator != (const char * s, const SbString & str);
-COIN_DLL_API int operator != (const SbString & str1, const SbString & str2);
+inline int operator==(const SbString & str, const char * s)
+{ return (cc_string_compare_text(str.str.pointer, s) == 0); }
+inline int operator==(const char * s, const SbString & str)
+{ return (cc_string_compare_text(s, str.str.pointer) == 0); }
+inline int operator==(const SbString & str1, const SbString & str2)
+{ return (cc_string_compare_text(str1.str.pointer, str2.str.pointer) == 0); }
+
+inline int operator!=(const SbString & str, const char * s)
+{ return (cc_string_compare_text(str.str.pointer, s) != 0); }
+inline int operator!=(const char * s, const SbString & str)
+{ return (cc_string_compare_text(s, str.str.pointer) != 0); }
+inline int operator!=(const SbString & str1, const SbString & str2)
+{ return (cc_string_compare_text(str1.str.pointer, str2.str.pointer) != 0); }
 
 #ifndef COIN_INTERNAL
 // For Open Inventor compatibility.
Index: src/base/SbString.cpp
===================================================================
RCS file: /export/cvsroot/Coin/src/base/SbString.cpp,v
retrieving revision 1.21
diff -u -r1.21 SbString.cpp
--- src/base/SbString.cpp	22 May 2002 07:14:17 -0000	1.21
+++ src/base/SbString.cpp	24 May 2002 21:20:46 -0000
@@ -2,7 +2,7 @@
  *
  *  This file is part of the Coin 3D visualization library.
  *  Copyright (C) 1998-2001 by Systems in Motion.  All rights reserved.
- *  
+ *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU General Public License
  *  version 2 as published by the Free Software Foundation.  See the
@@ -26,11 +26,10 @@
   \brief The SbString class is a string class with convenience functions for string operations.
   \ingroup base
 
-  Internally for the Coin library, this is the class used for storing
-  and working with character strings. It automatically takes care of
-  supporting all the "bookkeeping" tasks usually associated with
-  working with character strings, like memory allocation and
-  deallocation etc.
+  This is the class used for storing and working with character
+  strings. It automatically takes care of supporting all the
+  "bookkeeping" tasks usually associated with working with character
+  strings, like memory allocation and deallocation etc.
 
   This class should also be well suited for use by the application
   programmer throughout the application using the Coin library.
@@ -39,131 +38,10 @@
 */
 
 #include <Inventor/SbString.h>
-#if COIN_DEBUG
-#include <Inventor/errors/SoDebugError.h>
-#endif // COIN_DEBUG
-
-#include "../tidbits.h" // coin_vsnprintf()
-#include <assert.h>
-#include <string.h>
-
-
-/*!
-  This is the default constructor.  It initializes the string to be empty.
-*/
-
-SbString::SbString(void)
-{
-  this->sstring = this->staticstorage;
-  this->storagesize = SB_STRING_STATIC_STORAGE_SIZE;
-  this->sstring[0] = '\0';
-}
-
-/*!
-  This is the copy constructor.
-*/
-
-SbString::SbString(const SbString & str)
-{
-  this->sstring = this->staticstorage;
-  this->storagesize = SB_STRING_STATIC_STORAGE_SIZE;
-  *this = str.sstring;
-}
-
-/*!
-  This constructor assigns from the given string.
-*/
-
-SbString::SbString(const char * str)
-{
-  this->sstring = this->staticstorage;
-  this->storagesize = SB_STRING_STATIC_STORAGE_SIZE;
-  *this = str;
-}
-
-/*!
-  This constructor constructs a string from the given substring from
-  \a start to \a end indices inclusive. If \a end is -1, the substring
-  from \a start until the end of the string is used.
-*/
 
-SbString::SbString(const char * str, int start, int end)
-{
-#if COIN_DEBUG
-  int len=strlen(str);
-  if (start<0) {
-    SoDebugError::postWarning("SbString::SbString",
-                              "start index (%d) should be >= 0. Clamped to 0.",
-                              start);
-    start=0;
-  }
-  else if (start>len) {
-    SoDebugError::postWarning("SbString::SbString",
-                              "start index (%d) is out of bounds [0, %d>. "
-                              "Clamped to %d.", start, len, len-1);
-    start=len;
-  }
-  if (end<0) {
-    SoDebugError::postWarning("SbString::SbString",
-                              "end index (%d) should be >= 0. Clamped to 0.",
-                              end);
-    end=0;
-  }
-  else if (end>len) {
-    SoDebugError::postWarning("SbString::SbString",
-                              "end index (%d) is out of bounds [0, %d>. "
-                              "Clamped to %d.", end, len, len-1);
-    end=len;
-  }
-  if (start>end+1) {
-    SoDebugError::postWarning("SbString::SbString",
-                              "start index (%d) is greater than end index "
-                              "(%d). Empty string created.", start, end);
-    start=0;
-    end=-1;
-  }
-#endif // COIN_DEBUG
-
-  int size = end - start + 1;
-
-  if (size < SB_STRING_STATIC_STORAGE_SIZE) {
-    this->sstring = this->staticstorage;
-    this->storagesize = SB_STRING_STATIC_STORAGE_SIZE;
-  }
-  else {
-    this->sstring = new char[size+1];
-    this->storagesize = size+1;
-  }
-
-  (void)strncpy(this->sstring, str + start, size);
-  this->sstring[size]='\0';
-}
-
-/*!
-  Construct an SbString instance containing the \a digits of the
-  integer argument.
- */
-SbString::SbString(const int digits)
-{
-  this->sstring = this->staticstorage;
-  this->storagesize = SB_STRING_STATIC_STORAGE_SIZE;
-  this->sstring[0] = '\0';
-
-  this->addIntString(digits);
-}
-
-/*!
-  Constructs a string from the given integer (e.g. intToString(42)
-  creates the string "42"), and adds this to the contents of the
-  string.
-*/
-void
-SbString::addIntString(const int value)
-{
-  SbString s;
-  (void)s.sprintf("%d", value);
-  *this += s;
-}
+// FIXME: translate the find() and findAll() methods to C (will first
+// need a growable array in C to handle the second argument to
+// findAll()). 20020522 mortene.
 
 // Helper function for find() and findAll().
 static void
@@ -172,7 +50,7 @@
   int len = str.getLength();
   pi.append(0);
   int k = 0;
-  
+
   for (int q = 1; q < len; q++){
     while(k > 0 && (str.operator[](k) != str.operator[](q)))
       k = pi.get(k);
@@ -181,8 +59,8 @@
     pi.append(k);
   }
 }
- 
- /*!
+
+/*!
   If \a s is found, the method returns the first index where \a s
   starts. Otherwise it returns -1.
 
@@ -197,7 +75,7 @@
 {
   int lenthis = this->getLength();
   int lenstr = str.getLength();
-  
+
   if (!lenthis) return -1;
   if (lenstr > lenthis) return -1;
 
@@ -216,8 +94,8 @@
   }
   return -1;
 }
- 
- /*!
+
+/*!
   All occurences of \a str is represented in \a found as indices to
   the characters where \a str starts. If 1 or more is found, \c TRUE
   is returned, else \c FALSE is returned.
@@ -227,7 +105,8 @@
 
   \sa SbString::find()
   \since 2002-02-19
- */
+*/
+
 SbBool
 SbString::findAll(const SbString & str, SbIntList & found) const
 {
@@ -257,7 +136,50 @@
   return TRUE;
 }
 
+
+
+/*!
+  \fn SbString::SbString(void)
+  This is the default constructor.  It initializes the string to be empty.
+*/
+
 /*!
+  \fn SbString::SbString(const SbString & str)
+  This is the copy constructor.
+*/
+
+/*!
+  \fn SbString::SbString(const char * str)
+  This constructor assigns from the given string.
+*/
+
+/*!
+  \fn SbString::SbString(const char * str, int start, int end)
+
+  This constructor constructs a string from the given substring from
+  \a start to \a end indices inclusive. If \a end is -1, the substring
+  from \a start until the end of the string is used.
+*/
+
+
+/*!
+  \fn SbString::SbString(const int digits)
+
+  Construct an SbString instance containing the \a digits of the
+  integer argument.
+ */
+
+/*!
+  \fn void SbString::addIntString(const int value)
+
+  Constructs a string from the given integer (e.g. intToString(42)
+  creates the string "42"), and adds this to the contents of the
+  string.
+*/
+
+/*!
+  \fn SbString SbString::getSubString(int startidx, int endidx) const
+
   This method returns a new string which contains a substring defined by the
   given indices \a startidx and \a endChar (inclusive).
   If \a endChar is -1, the substring from \a startidx to the end of the
@@ -268,320 +190,142 @@
   SbString::getSubString(0, 3), the returned string will be "foo/".
 */
 
-SbString
-SbString::getSubString(int startidx, int endidx) const
-{
-  if (endidx == -1) endidx = this->getLength()-1;
-
-#if COIN_DEBUG
-  if (endidx < 0 || endidx >= this->getLength()) {
-    SoDebugError::postWarning("SbString::getSubString",
-                              "endidx index %d out of bounds.",
-                              endidx);
-    return SbString("");
-  }
-  if (startidx < 0 || startidx >= this->getLength()) {
-    SoDebugError::postWarning("SbString::getSubString",
-                              "startidx index %d out of bounds.",
-                              startidx);
-    return SbString("");
-  }
-  if (startidx > endidx) {
-    SoDebugError::postWarning("SbString::getSubString",
-                              "startidx idx %d larger than endidx idx %d.",
-                              startidx, endidx);
-    return SbString("");
-  }
-#endif // COIN_DEBUG
-  return SbString(this->sstring, startidx, endidx);
-}
-
 /*!
+  \fn void SbString::deleteSubString(int startidx, int endidx)
+
   This method deletes the substring defined by \a startidx and \a endidx
   (inclusive).  If \a endidx is -1, the substring from \a startidx to the
   end of the string is deleted.
 */
 
-void
-SbString::deleteSubString(int startidx, int endidx)
-{
-  int len = this->getLength();
-  if (endidx == -1) endidx = len - 1;
-
-#if COIN_DEBUG
-  if (startidx < 0 || startidx >= len || endidx < 0 || endidx >= len ||
-      startidx > endidx) {
-    SoDebugError::postWarning("SbString::deleteSubString",
-                              "invalid arguments [%d, %d] for string ``%s''",
-                              startidx, endidx, this->sstring);
-    return;
-  }
-#endif // COIN_DEBUG
-
-  (void)memmove(this->sstring + startidx, this->sstring + endidx + 1,
-                strlen(this->sstring) - endidx);
-}
-
 /*!
-  The destructor.
-*/
+  \fn SbString::~SbString()
 
-SbString::~SbString()
-{
-  if (this->sstring != this->staticstorage) delete[] this->sstring;
-}
+  The destructor. Deallocates any internal resources used during the
+  lifetime of the SbString instance.
+*/
 
 /*!
+  \fn uint32_t SbString::hash(void)
+
   This method returns a reasonable hash value for the current string.
 
   \sa uint32_t SbString::hash(const char * s)
 */
 
-uint32_t
-SbString::hash(void)
-{
-  return SbString::hash(this->sstring);
-}
-
 /*!
+  \fn uint32_t SbString::hash(const char * s)
+
   This static method returns a hash value for the given string.
 */
 
-uint32_t
-SbString::hash(const char * s)
-{
-  uint32_t total, shift;
-
-  total = shift = 0;
-  while (*s) {
-    total = total ^ ((*s) << shift);
-    shift+=5;
-    if (shift>24) shift -= 24;
-    s++;
-  }
-  return total;
-}
-
 /*!
+  \fn int SbString::getLength(void) const
+
   This method returns the length of the string.
 */
-int
-SbString::getLength(void) const
-{
-  // FIXME: jeez.. shouldn't this be cached? 20011123 mortene.
-  return strlen(this->sstring);
-}
 
 /*!
+  \fn const char * SbString::getString(void) const
+
   This method returns the pointer to the string (character array).
 */
 
-const char *
-SbString::getString(void) const
-{
-  return this->sstring;
-}
-
 /*!
+  \fn void SbString::makeEmpty(SbBool freeold)
+
   This method clears the string, making it an empty string ("").
-  If \a freeold is \c TRUE (which is the default), the memory used by the
-  old string is freed.  Otherwise, memory will be kept and reused when the
-  string is manipulated later.
+  If \a freeold is \c TRUE (which is the default), the memory used by
+  the old string is freed.  Otherwise, memory will be kept and reused
+  when the string is manipulated later.
 */
 
-void
-SbString::makeEmpty(SbBool freeold)
-{
-  if (this->sstring != this->staticstorage) {
-    if (freeold) delete[] this->sstring;
-    this->sstring = this->staticstorage;
-    this->storagesize = SB_STRING_STATIC_STORAGE_SIZE;
-  }
-  this->sstring[0] = '\0';
-}
-
 /*!
+  \fn char SbString::operator[](int index) const
+
   Returns character at position \a index in the string.
 
   \sa getSubString()
 */
-char
-SbString::operator [](int index) const
-{
-#if COIN_DEBUG
-  if (index < 0 || index >= this->getLength()) {
-    SoDebugError::postWarning("SbString::operator[]",
-                              "index %d out of bounds.", index);
-    return 0;
-  }
-#endif // COIN_DEBUG
-  return this->sstring[index];
-}
 
 /*!
+  \fn SbString & SbString::operator=(const char * str)
+
   This is the assignment operator.
 */
 
-SbString &
-SbString::operator =(const char * str)
-{
-  static char dummystring[] = "";
-  if (str == NULL) str = dummystring; // handle NULL pointers
-
-  int size = strlen(str) + 1;
-
-  // Detect if the str pointer is within our own string buffer.
-  if (str >= this->sstring && str < (this->sstring + this->storagesize)) {
-    this->deleteSubString(0, str - this->sstring);
-    return *this;
-  }
-
-  if (size > this->storagesize) this->expand(size - strlen(this->sstring) - 1);
-  (void)strcpy(this->sstring, str);
-  return *this;
-}
-
 /*!
+  \fn SbString & SbString::operator=(const SbString & str)
+
   Assign from the given string.
 */
 
-SbString &
-SbString::operator = (const SbString & str)
-{
-  return (*this = str.sstring);
-}
-
 /*!
+  \fn SbString & SbString::operator+=(const char * str)
+
   Concatenate the given string to the end of the current one.
 */
 
-SbString &
-SbString::operator +=(const char * str)
-{
-  if (str) {
-    this->expand(strlen(str));
-    (void)strcat(this->sstring, str);
-  }
-  return *this;
-}
-
 /*!
+  \fn SbString & SbString::operator+=(const SbString & str)
+
   Concatenate the given string to the end of the current one.
 */
 
-SbString &
-SbString::operator +=(const SbString & str)
-{
-  (*this) += str.getString();
-  return *this;
-}
-
 /*!
+  \fn SbString & SbString::operator+=(const char c)
+
   Concatenate the given character to the end of the current string.
 
   \note This member function is not compatible with OpenInventor.
 */
 
-SbString &
-SbString::operator +=(const char c)
-{
-  this->expand(1);
-  int pos = strlen(this->sstring);
-  this->sstring[pos] = c;
-  this->sstring[pos+1] = '\0';
-  return *this;
-}
-
 /*!
+  \fn int SbString::operator!(void) const
+
   This unary operator results in \c TRUE if the current string is empty ("")
   or \c FALSE otherwise.
 */
 
-int
-SbString::operator ! (void) const
-{
-  return (this->sstring[0] == '\0');
-}
-
 /*!
+  \fn int operator==(const SbString & str, const char * s)
+
   Equality operator. Check if the strings have the same contents.
 */
 
-int
-operator ==(const SbString & str, const char * s)
-{
-  return s && (str.sstring[0] == s[0]) && (strcmp(str.sstring, s) == 0);
-}
-
 /*!
+  \fn int operator==(const char * s, const SbString & str)
+
   Equality operator. Check if the strings have the same contents.
 */
 
-int
-operator == (const char * s, const SbString & str)
-{
-  return (str == s);
-}
-
 /*!
+  \fn int operator==(const SbString & str1, const SbString & str2)
+
   Equality operator. Check if the strings have the same contents.
 */
 
-int
-operator == (const SbString & str1, const SbString & str2)
-{
-  return (str1 == str2.sstring);
-}
-
 /*!
+  \fn int operator!=(const SbString & str, const char * s)
+
   Inequality operator.
 */
 
-int
-operator !=(const SbString & str, const char * s)
-{
-  return ((str == s) ? FALSE : TRUE);
-}
-
 /*!
+  \fn int operator!=(const char * s, const SbString & str)
+
   Inequality operator.
 */
 
-int
-operator != (const char * s, const SbString & str)
-{
-  return (str != s);
-}
-
 /*!
+  \fn int operator!=(const SbString & str1, const SbString & str2)
+
   Inequality operator.
 */
 
-int
-operator != (const SbString & str1, const SbString & str2)
-{
-  return (str1 != str2.sstring);
-}
-
-// Set the internal buffer size to the length of the current string
-// plus additional plus 1.
-void
-SbString::expand(int additional)
-{
-  int newsize = strlen(this->sstring) + additional + 1;
-
-  if (newsize > this->storagesize) {
-    char * newstring = new char[newsize];
-    (void)strcpy(newstring, this->sstring);
-
-    if (this->sstring != this->staticstorage) delete[] this->sstring;
-
-    this->sstring = newstring;
-    this->storagesize = newsize;
-  }
-}
-
 /*!
+  \fn SbString & SbString::sprintf(const char * formatstr, ...)
+
   Set SbString instance to the formatted string \a formatstr,
   replacing the current contents.  The control characters within \a
   formatstr and the remaining arguments should follow the conventions
@@ -590,24 +334,10 @@
   Note that this function is not part of the original Open Inventor
   API.
 */
-SbString &
-SbString::sprintf(const char * formatstr, ...)
-{
-  va_list args;
-  va_start(args, formatstr);
-
-  SbBool expand;
-  do {
-    int length = coin_vsnprintf(this->sstring, this->storagesize, formatstr, args);
-    expand = (length == -1);
-    if (expand) this->expand(1024); // increase linearly in 1Kb intervals
-  } while (expand);
-
-  va_end(args);
-  return *this;
-}
 
 /*!
+  \fn SbString & SbString::vsprintf(const char * formatstr, va_list args)
+
   Set SbString instance to the formatted string \a formatstr,
   replacing the current contents.  The control characters within \a
   formatstr and the arguments of the \a args argument list should
@@ -616,29 +346,10 @@
   Note that this function is not part of the original Open Inventor
   API.
 */
-SbString &
-SbString::vsprintf(const char * formatstr, va_list args)
-{
-  SbBool expand;
-  do {
-    int length = coin_vsnprintf(this->sstring, this->storagesize, formatstr, args);
-    expand = (length == -1);
-    if (expand) this->expand(1024); // increase linearly in 1Kb intervals
-  } while (expand);
-
-  return *this;
-}
-
 
 /*!
+  \fn void SbString::print(FILE * file) const
+
   Dump the state of this object to the \a file stream.  Only works in
   debug version of library, method does nothing in an optimized compile.
 */
-
-void
-SbString::print(FILE * file) const
-{
-#if COIN_DEBUG
-  (void)fprintf(file, "'%s'\n", this->getString());
-#endif // COIN_DEBUG
-}
