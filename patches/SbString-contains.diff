Patch by Lars-Ivar Igesund to add substring-searching functionality to
SbString, which is a great idea. (It's surprising that this has never
been part of the SbString API before.)

There are certain actions which should be taken with this before
applying:

        * don't use operator[], but access the internal char-array
          directly, for efficiency reasons

        * audit the code to make sure we never overrun the length of
          any of the strings, no matter what kind of input string, or
          how the "this" string looks: wwhat if one or both of them
          are the empty string? what if the input string is longer
          than the "this" string? etc

        * write a C version of the new function for cc_string()

..and also, when it is eventually committed:

        * make a diff and stuff it into Coin-1/patchqueue/ for
          inclusion in Coin 1.1.0

        * grep the Coin sourcecode to see if we're doing SbString
          searching anywhere, where we could replace that code with
          just calling this function instead

<mortene@sim.no>
-- 


? SbString-find-findAll.diff
Index: include/Inventor/SbString.h
===================================================================
RCS file: /export/cvsroot/Coin-1/include/Inventor/SbString.h,v
retrieving revision 1.2
diff -u -r1.2 SbString.h
--- include/Inventor/SbString.h	9 Jan 2002 13:36:24 -0000	1.2
+++ include/Inventor/SbString.h	19 Feb 2002 10:52:58 -0000
@@ -22,6 +22,7 @@
 
 #include <Inventor/system/inttypes.h>
 #include <Inventor/SbBasic.h>
+#include <Inventor/lists/SbIntList.h>
 
 #include <stdio.h>
 #include <stdarg.h>
@@ -44,6 +45,8 @@
   const char * getString(void) const;
   SbString getSubString(int startidx, int endidx = -1) const;
   void deleteSubString(int startidx, int endidx = -1);
+  int find(const SbString & str) const;
+  SbBool findAll(const SbString & str, SbIntList & found) const;
 
   void addIntString(const int value);
 
Index: src/base/SbString.cpp
===================================================================
RCS file: /export/cvsroot/Coin-1/src/base/SbString.cpp,v
retrieving revision 1.8
diff -u -r1.8 SbString.cpp
--- src/base/SbString.cpp	9 Jan 2002 13:36:27 -0000	1.8
+++ src/base/SbString.cpp	19 Feb 2002 10:52:59 -0000
@@ -226,6 +226,98 @@
                 strlen(this->sstring) - endidx);
 }
 
+static void
+computePrefixFunction(SbIntList & pi, const SbString & str)
+{
+  int len = str.getLength();
+  pi.append(0);
+  int k = 0;
+  
+  for (int q = 1; q < len; q++){
+    while(k > 0 && (str.operator[](k) != str.operator[](q)))
+      k = pi.get(k);
+    if (str.operator[](k) == str.operator[](q))
+      k++;
+    pi.append(k);
+  }
+}
+
+/*!
+  If \a s is found, the method returns the first index
+  where \a s starts. Otherwise it returns -1.
+
+  Note: SbString::find is an extension to the original Open Inventor API
+
+  \sa SbBool SbString::findAll(SbIntList & found, const SbString & str)
+  \since 2002-02-19
+*/
+
+int
+SbString::find(const SbString & str) const
+{
+  int lenthis = this->getLength();
+  int lenstr = str.getLength();
+  
+  if(!lenthis) return -1;
+  if(lenstr > lenthis) return -1;
+
+  SbIntList pi;
+  computePrefixFunction(pi, str);
+  int q = 0;
+
+  for (int i = 0; i < lenthis; i ++){
+    while (q > 0 && (str.operator[](q) != this->sstring[i]))
+      q = pi.operator[](q - 1);
+    if (str.operator[](q) == this->sstring[i])
+      q++;
+    if (q == lenstr){
+      return (i - (lenstr - 1));
+    }
+  }
+  return -1;
+}
+
+/*!
+  All occurences of \a str is represented in \a found as indices
+  to the characters where \a str starts. If 1 or more is found,
+  \c TRUE is returned, else \c FALSE is returned.
+
+  Note: SbString::findAll is an extension to the original Open Inventor API
+
+  \sa int SbString::find(const SbString & str)
+  \since 2002-02-19
+*/
+
+SbBool
+SbString::findAll(const SbString & str, SbIntList & found) const
+{
+  // The KMP string matching algorithm is used for this method
+  int lenthis = this->getLength();
+  int lenstr = str.getLength();
+  found.truncate(0);
+
+  if(!lenthis) return FALSE;
+  if(lenstr > lenthis) return FALSE;
+
+  SbIntList pi;
+  computePrefixFunction(pi, str);
+  int q = 0;
+
+  for (int i = 0; i < lenthis; i ++){
+    while (q > 0 && (str.operator[](q) != this->sstring[i]))
+      q = pi.operator[](q - 1);
+    if (str.operator[](q) == this->sstring[i])
+      q++;
+    if (q == lenstr){
+      found.append(i - (lenstr - 1));
+      q = pi.operator[](q - 1);
+    }
+  }
+  if(!found.getLength()) return FALSE;
+  return TRUE;
+}
+
+
 /*!
   The destructor.
 */
