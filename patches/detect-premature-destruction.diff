This patch is for the detection of premature destruction when the
reference count of an SoBase-derived instances dips to zero. This
seems to be a very common application programmer's mistake.

I believe it should be applicable for Coin-1 aswell, as I can't see
how this should break ABI-compatibility -- even though I'm changing
the bitpattern layout of a private variable.

I've tested it to see that it actually works where it should have
effect. I'm running with it now to make sure it doesn't give false
positives under any common circumstance -- which would be
catastrophic.

<mortene@sim.no>
-- 

Index: include/Inventor/misc/SoBase.h
===================================================================
RCS file: /export/cvsroot/Coin/include/Inventor/misc/SoBase.h,v
retrieving revision 1.24
diff -u -r1.24 SoBase.h
--- include/Inventor/misc/SoBase.h	26 Nov 2001 13:27:58 -0000	1.24
+++ include/Inventor/misc/SoBase.h	17 Feb 2002 13:11:07 -0000
@@ -123,10 +123,13 @@
   // appears. 20000124 mortene.
 #ifndef DOXYGEN_SKIP_THIS
   struct {
-    int16_t referencecount  : 15;
-    uint16_t writerefcount  : 15;
+    int16_t referencecount  : 13;
+    uint16_t writerefcount  : 13;
     unsigned int multirefs  :  1;
     unsigned int ingraph    :  1;
+    unsigned int alive      :  4;
+    // The number of bits should sum up to 32, so we don't allocate
+    // more than one machine word on a 32-bit platform.
   } objdata;
 #endif // DOXYGEN_SKIP_THIS
 
Index: src/misc/SoBase.cpp
===================================================================
RCS file: /export/cvsroot/Coin/src/misc/SoBase.cpp,v
retrieving revision 1.61
diff -u -r1.61 SoBase.cpp
--- src/misc/SoBase.cpp	17 Feb 2002 13:10:11 -0000	1.61
+++ src/misc/SoBase.cpp	17 Feb 2002 13:11:09 -0000
@@ -160,6 +160,12 @@
 SbBool SoBase::tracerefs = FALSE;
 uint32_t SoBase::writecounter = 0;
 
+// This can be any "magic" bitpattern of 4 bits which seems unlikely
+// to be randomly assigned to a memory byte upon destruction. I chose
+// "1101".  <mortene@sim.no>
+#define ALIVE_PATTERN 0xd
+
+
 /*!
   Constructor. The initial reference count will be set to zero.
  */
@@ -169,6 +175,16 @@
   this->objdata.writerefcount = 0;
   this->objdata.multirefs = FALSE;
   this->objdata.ingraph = FALSE;
+
+  // The 4 bits allocated for the "alive" bitpattern is used in
+  // SoBase::ref() to try to detect when the instance has been
+  // prematurely destructed. This is a very common mistake to make by
+  // application programmers (letting the refcount dip to zero before
+  // it should, that is), so the extra piece of assistance through the
+  // accompanying assert() in SoBase::ref() to detect memory
+  // corruption and help avoid mysterious crashes should be a Good
+  // Thing.
+  this->objdata.alive = ALIVE_PATTERN;
 }
 
 /*!
@@ -247,6 +263,10 @@
   SoDebugError::postInfo("SoBase::destroy", "delete this %p", this);
 #endif // debug
 
+  // Set the 4 bits of bitpattern to anything but the "magic" pattern
+  // used to check that we are still alive.
+  this->objdata.alive = (~ALIVE_PATTERN) & 0xf;
+
   // Sjølmord.
   delete this;
 
@@ -322,6 +342,16 @@
                            this->objdata.referencecount);
   }
 #endif // COIN_DEBUG
+
+  // For more information about this assert check, see the code
+  // comments on the objdata.alive initialization in the SoBase
+  // constructor.
+  assert(this->objdata.alive == ALIVE_PATTERN &&
+         "Detected an attempt to access an instance of an SoBase-derived "
+         "class after it was destructed!  This is very likely to be the "
+         "result of some grave programming error in the application / client "
+         "code -- causing premature destruction of a reference counted "
+         "object instance.");
 }
 
 /*!
