=====================================================================

002 Trying to parse this file causes an assert failure / crash (which
    should _never_ happen, of course, no matter how wrong the file
    is):

    ---8<-------8<-------8<-------8<-------8<-------8<-------8<----
    #Inventor V2.1 ascii

    Separator {
       TransformerDragger {
          translator1Switch Switch { }
          translator1LocateGroup LocateHighlight { }
       }
    }
    ---8<-------8<-------8<-------8<-------8<-------8<-------8<----

    => /home/mortene/code/coin-head/src/nodekits/SoBaseKit.cpp:1686:
         SbBool SoBaseKit::setPart(int, SoNode *):
         Assertion `oldIdx >= 0' failed.

    (After this has been fixed, should also try to fully export the
    internals of an unmodified SoTransformerDragger and then read it
    back in again, as the file above is a _very_ cut-down version of
    such a dump.)

    <mortene@sim.no> 20020205.

=====================================================================

003 There are seams in texturemaps on SGI Octane with "IMPACTSR"
    graphics hardware.

    Can at least be seen on the SoGuiExamples/nodes/texture
    example. Reported by Dan Stewart on coin-discuss. Cause not yet
    known. Hard to debug and fix without access to the platform in
    question.

    <mortene@sim.no> 20020205.

=====================================================================

005 Free memory read on connected SoSFEnum fields?

    This is an old problem which might have been fixed now, but we
    should check it with Valgrind: Purify used to report "Free memory
    read" when deleting SoSFEnum fields that were connected to other
    fields.

    <mortene@sim.no> 20020521.

=====================================================================

007 For the following stand-alone example, picking on the nurbscurve
    only partly works:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #include <Inventor/SoDB.h>
    #include <Inventor/SoInput.h>
    #include <Inventor/SoPickedPoint.h>
    #include <Inventor/events/SoLocation2Event.h>
    #include <Inventor/nodes/SoBaseColor.h>
    #include <Inventor/nodes/SoCone.h>
    #include <Inventor/nodes/SoCoordinate3.h>
    #include <Inventor/nodes/SoEventCallback.h>
    #include <Inventor/nodes/SoMarkerSet.h>
    #include <Inventor/nodes/SoSeparator.h>
    #include <Inventor/Qt/SoQt.h>
    #include <Inventor/Qt/viewers/SoQtExaminerViewer.h>

    SoCoordinate3 *coord;

    void mouseMoveCB(void *userData, SoEventCallback *eventCB)
    {
      const SoPickedPoint *pickP = eventCB->getPickedPoint();
      if(pickP){
        const float *xyz = pickP->getPoint().getValue();
        printf("xyz =%lf %lf %lf\n",xyz[0],xyz[1],xyz[2]);
        coord->point.setValue(xyz);
      }
    }

    const char * nurbscurve = "#Inventor V2.1 ascii\n\n"
    "Separator {"
    "   PickStyle {"
    "      style SHAPE"
    "   }"
    "   LightModel {"
    "      model BASE_COLOR"
    "   }"
    "   Coordinate3 {"
    "      point [ 1476.11 1460.84 -628.038,"
    "       1470.86 1447.8 -622.961,"
    "       1462.15 1424.9 -613.788,"
    "       1452.31 1396.07 -601.719,"
    "       1443.57 1368.74 -589.954,"
    "       1428.74 1318.74 -567.739,"
    "       1399.1 1199.31 -510.515,"
    "       1380.47 1084 -445.435,"
    "       1366.84 973.854 -378.304,"
    "       1361.86 927.129 -348.91,"
    "       1356.41 868.655 -311.219,"
    "       1351.93 814.353 -275.603,"
    "       1347.16 745.613 -229.666,"
    "       1342.98 674.034 -181.29,"
    "       1339.84 614.017 -140.592,"
    "       1336.44 546.811 -95.1583,"
    "       1331.26 446.458 -27.7185,"
    "       1321.74 299.504 68.5609,"
    "       1306.62 162.637 153.404,"
    "       1290.91 63.5896 211.906,"
    "       1276.65 -13.3307 256.203,"
    "       1255.13 -107.653 308.474,"
    "       1222.55 -219.064 367.003,"
    "       1195.21 -292.713 403.659,"
    "       1180.26 -329.3 421.348 ]"
    "   }"
    "   NurbsCurve {"
    "      numControlPoints 25"
    "      knotVector [ 0, 0, 0, 0,"
    "       0.0212654, 0.0372336, 0.0466221, 0.0653992,"
    "       0.117887, 0.239617, 0.255294, 0.302551,"
    "       0.318454, 0.354628, 0.395169, 0.43633,"
    "       0.477697, 0.498482, 0.551868, 0.649936,"
    "       0.748818, 0.781971, 0.815122, 0.876749,"
    "       0.938373, 1, 1, 1,"
    "       1 ]"
    "   }"
    "}";


    int
    main(int argc, char ** argv)
    {
      QWidget *window = SoQt::init(argv[0]);

      SoSeparator *root = new SoSeparator;

      //add a green marker to appear under cursor
      SoSeparator *marksep = new SoSeparator;
      root->addChild(marksep);
      SoBaseColor *markColor = new SoBaseColor;
      markColor->rgb.setValue(0,1,0);
      marksep->addChild(markColor);
      coord = new SoCoordinate3;
      marksep->addChild(coord);
      SoMarkerSet *mark = new SoMarkerSet;
      marksep->addChild(mark);
      mark->markerIndex=SoMarkerSet::PLUS_5_5;

      SoEventCallback *myEventCB = new SoEventCallback;
      root->addChild(myEventCB);
      myEventCB->addEventCallback(SoLocation2Event::getClassTypeId(),mouseMoveCB);

      SoInput in;
      in.setBuffer((void *)nurbscurve, strlen(nurbscurve));
      SoSeparator * nurbsep = SoDB::readAll(&in);
      assert(nurbsep);
      root->addChild(nurbsep);

      SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);
      viewer->setSceneGraph(root);
      viewer->show();
      SoQt::show(window);
      SoQt::mainLoop();
      return 0;
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    (Original test-code supplied by Nigel Murry.)

    Some other specifications for nurbscurves and nurbssurfaces tested
    works correctly.

    pederb has tracked this down to be likely to be caused by bugs in
    libGLU: a rendered curve is different from a tesselated curve (!).

    Hard to solve this *properly* without implementing our own
    nurbs-library. Are there any quick-fixes we could apply?

    <mortene@sim.no> 20020521.

=====================================================================

012 Buglet: the SoMaterial::shininess field is not clamped if it's >
    1.0. This causes OpenGL errors, at least with some drivers.

    (The other material field values are also likely to be able to
    cause problems like this.)

    mortene 20020625.

=====================================================================

013 Bounding box calculation of the scenegraph given below is
    sub-optimal.

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    Separator {
       Separator {
          Cube { }

          BaseColor { rgb 1 0 0 }
          Translation { translation +4 0 0 }
          Separator {
    	 Transform {
    	    translation 0 -0.5 0
    	    rotation 0 0 1 0.78
    	    scaleFactor 0.5 2 3
    	    scaleOrientation 1 0 0 0.78
    	    center 0.5 0.5 0.5
    	 }
    	 Cube { }
          }
       }

       Translation { translation 0 +6 0 }
       Separator {
          Cube { }

          BaseColor { rgb 1 0 0 }
          Translation { translation +4 0 0 }
          Separator {
    	 Transform {
    	    translation 10 -0.5 0 ~
    	    rotation 0 0 1 0.78
    	    scaleFactor 0.5 2 3
    	    scaleOrientation 1 0 0 0.78
    	    center 0.5 0.5 0.5
    	 }
    	 Cube { }
          }
       }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    A good strategy for investigating the bug is using the
    SoGuiExamples/engines/computexfbox example code to load the scene
    and view the resulting bbox.

    mortene 20020729.

=====================================================================

014 SoExtSelection with ALL_SHAPES selection doesn't always work
    properly with SoArray.

    Reproduce by running the SoGuiExamples/nodes/extselection example
    on the following scene:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    Array {
       numElements1 2
       separation1 3 0 0

       Cube { }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    ..if you select any _one_ of the cubes, I believe it works
    correctly: the SoArray with both cubes are selected. (Or does it
    -- should perhaps the correct policy be to select only that cube?
    Unlikely, but ask Peder about his opinion.)

    But if you draw up a lasso to select _both_ cubes, _none_ are
    actually selected.

    Note that it *does* work correctly for VISIBLE_SHAPES selection.

    mortene 20020806.

=====================================================================

015 SoExtSelection doesn't always work properly with SoMultipleCopy.

    Reproduce with the following scenegraph in the
    SoGuiExamples/nodes/extselection example:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    #Inventor V2.5 ascii

    Group {
       MultipleCopy {
          matrix [
           1 0 0 0
           0 1 0 0
           0 0 1 0
           0 0 0 1,

           1 0 0 0
           0 1 0 0
           0 0 1 0
           4 0 0 1,

           1 0 0 0
           0 1 0 0
           0 0 1 0
           -4 0 0 1,
          ]

          Cube {
          }
       }
    }

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    With ALL_SHAPES selection, you need to select either the middle
    cube by itself, or all three cubes at the same time to get the
    correct result. Selecting any two cubes, or the side cubes by
    themselves, will _not_ make the SoMultipleCopy get selected.

    With VISIBLE_SHAPES everything works.

    Update (after investigation by handegar): this is probably because
    shapes are toggled, so if any shape has multiple references in the
    selected area, it will first be selected, then un-selected, then
    selected, etc. If it's referenced an even number of times, it will
    finally end up un-selected. This is probably the reason for bug
    #014 aswell.

    mortene 20020806.

=====================================================================

016 Flawed initial interaction with SoSpotLightDragger.

    If one clicks and holds down the left mouse button on the
    cone-part that controls SoSpotLight::cutOffAngle (ie the
    lamp-shade looking part drawn by lines) and make just a very tiny
    movement, there will immediately be a major movement.

    *After* the initial "jump", the part will behave correctly.

    For convenience, here's the (trivial) scenegraph one can use to
    reproduce the problem in any viewer component:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    SpotLightDragger { }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    This bug definitely looks like there's a variable initialization
    missing, somewhere.

    mortene 20020813.

=====================================================================

017 If you drag one of the interaction tabs on an SoTabPlaneDragger
    past the one on the opposite side (that is: so the scaleFactor in
    that direction is close to 0.0), I can see 2 problems which are
    both probably related to the same bug:

        - the geometry "oscillates" around origo as long as the drag
          operation is held

        - if one releases the drag in this position, it's impossible
          to grab one of the tabs again (and the geometry is placed
          wrongly, use "View All" in an examiner viewer to see this)

    For convenience, here's the (trivial) scenegraph one can use to
    reproduce the problem in any viewer component:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    TabPlaneDragger { }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    I *guess* this should be fixed by placing some lower bound on the
    scalevector values, that somehow matches the lower reaches of
    floating point accuracy that we can still safely use without
    getting the artifacts mentioned above.

    mortene 20020813.

=====================================================================
