
typedef SbString mangleFunc(const char *);

/*
  This function returns a string that corresponds to how gcc 2.95.4
  mangles "static void <classname>::initClass(void)".
*/

static
SbString
gcc2_initClassMangling(const char * classname)
{
  assert(classname != NULL);
  int len = strlen(classname);
  SbString mangling;
  mangling.sprintf("initClass__%d%s", len, classname);
  return mangling;
}

/*
  This function returns a string that corresponds to how gcc3
  mangles "static void <classname>::initClass(void)".
*/
   
static
SbString
gcc3_initClassMangling(const char * classname)
{
  assert(classname != NULL);
  int len = strlen(classname);
  SbString mangling;
  mangling.sprintf("_ZN%d%s9initClassEv", len, classname);
  return mangling;
}

/*
  This function returns a string that corresponds to how Microsoft
  Visual C++ v6 mangles "static void <classname>::initClass(void)" in
  a __declspec(dllexport) context.
*/

static
SbString
msvc6_initClassMangling(const char * classname)
{
  assert(classname != NULL);
  SbString mangling;
  mangling.sprintf("?initClass@%s@@SAXXZ", classname);
  return mangling;
}

/*
  This function returns a string that corresponds to how IRIX MIPSpro
  CC 7.30 mangles "static void <classname>::initClass(void)".
*/

static
SbString
MIPSpro_CC_initClassMangling(const char * classname)
{
  assert(classname != NULL);
  int len = strlen(classname);
  SbString mangling;
  mangling.sprintf("initClass__%d%sSGv", len, classname);
  return mangling;
}

/* ********************************************************************** */

static mangleFunc * manglefunctions[] = {
  gcc2_initClassMangling,
  gcc3_initClassMangling,
  msvc6_initClassMangling,
  MIPSpro_CC_initClassMangling,
  (mangleFunc *) NULL
};

/*
  return the correct name mangling function, or NULL in case none seem
  appropriate
*/

static
mangleFunc *
getManglingFunction(void)
{
  static SbBool initialized = FALSE;
  static mangleFunc * manglefunc = NULL;
  if ( !initialized ) {
    int i;
    cc_libhandle handle = cc_dl_open(NULL);
    if ( handle == NULL ) {
      initialized = TRUE;
      return NULL;
    }
    for ( i = 0; (manglefunctions[i] != NULL) && (manglefunc == NULL); i++ ) {
      mangleFunc * attempt = manglefunctions[i];
      SbString symbol(attempt("SoBase"));
      if ( cc_dl_sym(handle, symbol.getString()) ) {
        // SoDebugError::postInfo("getManglingFunction", "chose mangling scheme %d", i);
        manglefunc = manglefunctions[i];
      }
    }
    cc_dl_close(handle);
#ifdef _MSC_VER
    if ( manglefunc == NULL )
      // dang, dlopen(NULL) on win32 didn't work, so we fall back to this...
      manglefunc = msvc6_initClassMangling;
#endif
    initialized = TRUE;
  }
  return manglefunc;
}

