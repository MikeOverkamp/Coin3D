/**************************************************************************\
 *
 *  This file is part of the Coin 3D visualization library.
 *  Copyright (C) 1998-2002 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  ("GPL") version 2 as published by the Free Software Foundation.
 *  See the file LICENSE.GPL at the root directory of this source
 *  distribution for additional information about the GNU GPL.
 *
 *  For using Coin with software that can not be combined with the GNU
 *  GPL, and for taking advantage of the additional benefits of our
 *  support services, please contact Systems in Motion about acquiring
 *  a Coin Professional Edition License.
 *
 *  See <URL:http://www.coin3d.org> for  more information.
 *
 *  Systems in Motion, Prof Brochs gate 6, 7030 Trondheim, NORWAY.
 *  <URL:http://www.sim.no>.
 *
\**************************************************************************/

#include <assert.h>
#include <float.h>

#include <Inventor/errors/SoDebugError.h>
#include <Inventor/SbPlane.h>
#include <Inventor/SbLine.h>
#include <Inventor/SbBox3f.h>

#include "SbTri3f.ih"

/*!
  \class SbTri3f noheader
  \brief A class that at this point in time has one purpose - figuring out
  if two triangles intersect each other.
  \ingroup base

  This class is so limited in functionality that it is not included in the
  public Coin API for now.

  The internals will probably be changed as well, as the a, b, c
  representation isn't very convenient for linear algebra purposes.  But
  as a public base class, the internal representation should be fixed, and
  made part of the private section of the public header.

  \since 20021022
*/

// Here's an idea for an alternate approach for this class:
//
// Let's say the triangle is defined as (0,0,0), (1,0,0), (1,1,0)
// transformed through a transformation matrix.
//
// With this representation, a triangle would take the 16 floats of
// an SbMatrix instead of 9 for the vertex positions.
//
// Finding the normal of the triangle is a multVecMatrix() call
// Finding a, b, and c are multVecMatrix() calls
// Finding the area is a multVecMatrix() and a getLength() call
//
// Doing intersection testing would be done by transforming one primitive
// into the local coordinate system of the triangle (by using the inverse
// matrix).  Given the simplicity of the a, b, and c coordinates of the
// localspace triangle, the intersection testing ought to be a lot more
// trivial to perform than in fully flexible 3D space.  Especially the
// case of triangles in the same plane...

#define SBTRI_DEBUG 0

// *************************************************************************

class SbTri3fP {
public:
  SbTri3fP(void) {}
  SbTri3fP(SbTri3fP * t)
    : a(t->a), b(t->b), c(t->c) {}
  SbTri3fP(const SbVec3f & na, const SbVec3f & nb, const SbVec3f & nc)
    : a(na), b(nb), c(nc)
  { assert(a != b && a != c && b != c); }

  SbVec3f a;
  SbVec3f b;
  SbVec3f c;
};

// *************************************************************************

#define PRIVATE(obj) ((obj)->pimpl)

SbTri3f::SbTri3f(void)
  : pimpl(new SbTri3fP)
{
}

SbTri3f::SbTri3f(const SbTri3f & t)
  : pimpl(new SbTri3fP(PRIVATE(&t)))
{
}

SbTri3f::SbTri3f(const SbVec3f & a, const SbVec3f & b, const SbVec3f & c)
  : pimpl(new SbTri3fP(a, b, c))
{
}

SbTri3f::~SbTri3f(void)
{
  delete PRIVATE(this);
}

SbTri3f &
SbTri3f::setValue(const SbTri3f & t)
{
  PRIVATE(this)->a = PRIVATE(&t)->a;
  PRIVATE(this)->b = PRIVATE(&t)->b;
  PRIVATE(this)->c = PRIVATE(&t)->c;
  assert(PRIVATE(this)->a != PRIVATE(this)->b && PRIVATE(this)->a != PRIVATE(this)->c && PRIVATE(this)->b != PRIVATE(this)->c);
  return *this;
}

SbTri3f &
SbTri3f::setValue(const SbVec3f & a, const SbVec3f & b, const SbVec3f & c)
{
  assert(a != b && a != c && b != c);
  PRIVATE(this)->a = a;
  PRIVATE(this)->b = b;
  PRIVATE(this)->c = c;
  return *this;
}

void
SbTri3f::getValue(SbTri3f & t) const
{
  PRIVATE(&t)->a = PRIVATE(this)->a;
  PRIVATE(&t)->b = PRIVATE(this)->b;
  PRIVATE(&t)->c = PRIVATE(this)->c;
}

void
SbTri3f::getValue(SbVec3f & a, SbVec3f & b, SbVec3f & c) const
{
  a = PRIVATE(this)->a;
  b = PRIVATE(this)->b;
  c = PRIVATE(this)->c;
}

SbTri3f &
SbTri3f::operator = (const SbTri3f & t)
{
  PRIVATE(this)->a = PRIVATE(&t)->a;
  PRIVATE(this)->b = PRIVATE(&t)->b;
  PRIVATE(this)->c = PRIVATE(&t)->c;
  return *this;
}

// *************************************************************************

SbBool
SbTri3f::intersect(const SbTri3f & t) const
{
  // FIXME: remove all "programming logic" error messages and asserts from
  // this function when it's verified that those paths can't be taken.

  SbVec3f a1(PRIVATE(this)->a);
  SbVec3f b1(PRIVATE(this)->b);
  SbVec3f c1(PRIVATE(this)->c);
  SbPlane plane1(a1, b1, c1);

  SbVec3f a2(PRIVATE(&t)->a);
  SbVec3f b2(PRIVATE(&t)->b);
  SbVec3f c2(PRIVATE(&t)->c);
  SbPlane plane2(a2, b2, c2);

  // FIXME: can ((n1 == -n2) && (d1 == -d2)) really happen?
  if ( SBTRI_DEBUG &&
       (plane1.getNormal() == -plane2.getNormal()) &&
       (plane1.getDistanceFromOrigin() == -plane2.getDistanceFromOrigin()) ) {
    SoDebugError::post("SbTri3f::intersect", "The (n1 == -n2 && d1 == -d2) case happened");
  }
  if ( plane1.getNormal() == plane2.getNormal() ) {
    // fprintf(stderr, "normals are equal\n");
    if ( plane1.getDistanceFromOrigin() != plane2.getDistanceFromOrigin() )
      return FALSE; // parallel planes
    // we work around coplanar intersection testing by making it a case of
    // biplanar intersection testing.

    int vertex = 1;
    float distance = a1.sqrLength();
    float d;
    if ( (d = b1.sqrLength()) > distance ) {
      distance = d;
      vertex = 2;
    } else if ( (d = c1.sqrLength()) > distance ) {
      distance = d;
      vertex = 3;
    } else if ( (d = a2.sqrLength()) > distance ) {
      distance = d;
      vertex = 4;
    } else if ( (d = b2.sqrLength()) > distance ) {
      distance = d;
      vertex = 5;
    } else if ( (d = c2.sqrLength()) > distance ) {
      distance = d;
      vertex = 6;
    }
    switch ( vertex ) {
    case 1:
      break;
    case 2:
      do { SbVec3f temp(a1); a1 = b1; b1 = c1; c1 = temp; } while ( FALSE );
      break;
    case 3:
      do { SbVec3f temp(a1); a1 = c1; c1 = b1; b1 = temp; } while ( FALSE );
      break;
    case 4:
      do { SbVec3f temp(a1); a1 = a2; a2 = temp; } while ( FALSE );
      do { SbVec3f temp(b1); b1 = b2; b2 = temp; } while ( FALSE );
      do { SbVec3f temp(c1); c1 = c2; c2 = temp; } while ( FALSE );
      break;
    case 5:
      do { SbVec3f temp(a1); a1 = b2; b2 = temp; } while ( FALSE );
      do { SbVec3f temp(b1); b1 = c2; c2 = temp; } while ( FALSE );
      do { SbVec3f temp(c1); c1 = a2; a2 = temp; } while ( FALSE );
      break;
    case 6:
      do { SbVec3f temp(a1); a1 = c2; c2 = temp; } while ( FALSE );
      do { SbVec3f temp(b1); b1 = a2; a2 = temp; } while ( FALSE );
      do { SbVec3f temp(c1); c1 = b2; b2 = temp; } while ( FALSE );
      break;
    }
    vertex = 1;
    distance = (a2-a1).sqrLength();
    if ( (d = (b2-a1).sqrLength()) > distance ) {
      distance = d;
      vertex = 2;
    } else if ( (d = (c2-a1).sqrLength()) > distance ) {
      distance = d;
      vertex = 3;
    }
    switch ( vertex ) {
    case 1:
      break;
    case 2:
      do { SbVec3f temp(a2); a2 = b2; b2 = b2; c2 = temp; } while ( FALSE );
      break;
    case 3:
      do { SbVec3f temp(a2); a2 = c2; c2 = b2; b2 = temp; } while ( FALSE );
      break;
    }

    a1 = a1 + plane1.getNormal();
    a2 = a2 + plane1.getNormal();
    // regenerate planes
    plane1 = SbPlane(a1, b1, c1);
    plane2 = SbPlane(a2, b2, c2);
  } else {
    // fprintf(stderr, "normals are different\n");
  }

  // set up point a on one side, and b and c on the other

  const SbBool a1hs = plane2.isInHalfSpace(a1);
  const SbBool b1hs = plane2.isInHalfSpace(b1);
  const SbBool c1hs = plane2.isInHalfSpace(c1);
  if ( (a1hs == b1hs) && (a1hs == c1hs) ) {
    // no intersection
    return FALSE;
  } else if ( a1hs == c1hs ) { // b is in other halfspace
    SbVec3f temp(a1); a1 = b1; b1 = c1; c1 = temp;
  } else if ( a1hs == b1hs ) { // c is in other halfspace
    SbVec3f temp(a1); a1 = c1; c1 = b1; b1 = temp;
  }

  const SbBool a2hs = plane1.isInHalfSpace(a2);
  const SbBool b2hs = plane1.isInHalfSpace(b2);
  const SbBool c2hs = plane1.isInHalfSpace(c2);
  if ( (a2hs == b2hs) && (a2hs == c2hs) ) {
    // no intersection
    return FALSE;
  } else if ( a2hs == c2hs ) { // b is in other halfspace
    SbVec3f temp(a2); a2 = b2; b2 = c2; c2 = temp;
  } else if ( a2hs == b2hs ) { // c is in other halfspace
    SbVec3f temp(a2); a2 = c2; c2 = b2; b2 = temp;
  }

  // find intersection points on line for triangles
  SbVec3f p11, p12;
  if ( !plane2.intersect(SbLine(a1, b1), p11) ) {
    // should really never happen
    if ( COIN_DEBUG && SBTRI_DEBUG ) {
      SoDebugError::post("SbTri3f::intersect", "programming logic error 1");
      SoDebugError::post("-", "SbVec3f a1(%g, %g, %g);", a1[0], a1[1], a1[2]);
      SoDebugError::post("-", "SbVec3f b1(%g, %g, %g);", b1[0], b1[1], b1[2]);
      SoDebugError::post("-", "SbVec3f c1(%g, %g, %g);", c1[0], c1[1], c1[2]);
      SoDebugError::post("-", "SbVec3f a2(%g, %g, %g);", a2[0], a2[1], a2[2]);
      SoDebugError::post("-", "SbVec3f b2(%g, %g, %g);", b2[0], b2[1], b2[2]);
      SoDebugError::post("-", "SbVec3f c2(%g, %g, %g);", c2[0], c2[1], c2[2]);
      assert(0);
    }
    return FALSE;
  }
  if ( !plane2.intersect(SbLine(a1, c1), p12) ) {
    // should never happen
    if ( COIN_DEBUG && SBTRI_DEBUG ) {
      SoDebugError::post("SbTri3f::intersect", "programming logic error 2");
      SoDebugError::post("-", "SbVec3f a1(%g, %g, %g);", a1[0], a1[1], a1[2]);
      SoDebugError::post("-", "SbVec3f b1(%g, %g, %g);", b1[0], b1[1], b1[2]);
      SoDebugError::post("-", "SbVec3f c1(%g, %g, %g);", c1[0], c1[1], c1[2]);
      SoDebugError::post("-", "SbVec3f a2(%g, %g, %g);", a2[0], a2[1], a2[2]);
      SoDebugError::post("-", "SbVec3f b2(%g, %g, %g);", b2[0], b2[1], b2[2]);
      SoDebugError::post("-", "SbVec3f c2(%g, %g, %g);", c2[0], c2[1], c2[2]);
      assert(0);
    }
    return FALSE;
  }

  SbVec3f p21, p22;
  if ( !plane1.intersect(SbLine(a2, b2), p21) ) {
    // should never happen
    // but since it does, it means something
    // possibly that a2 and b2 are in plane1, and halfspace values were wrong in
    // some way.  we should either return FALSE or set p21 to something
    if ( COIN_DEBUG && SBTRI_DEBUG ) {
      SoDebugError::post("SbTri3f::intersect", "programming logic error 3");
      SoDebugError::post("-", "SbVec3f a1(%g, %g, %g);", a1[0], a1[1], a1[2]);
      SoDebugError::post("-", "SbVec3f b1(%g, %g, %g);", b1[0], b1[1], b1[2]);
      SoDebugError::post("-", "SbVec3f c1(%g, %g, %g);", c1[0], c1[1], c1[2]);
      SoDebugError::post("-", "SbVec3f a2(%g, %g, %g);", a2[0], a2[1], a2[2]);
      SoDebugError::post("-", "SbVec3f b2(%g, %g, %g);", b2[0], b2[1], b2[2]);
      SoDebugError::post("-", "SbVec3f c2(%g, %g, %g);", c2[0], c2[1], c2[2]);
      assert(0);
    }
    return FALSE;
  }
  if ( !plane1.intersect(SbLine(a2, c2), p22) ) {
    // should never happen
    if ( COIN_DEBUG && SBTRI_DEBUG ) {
      SoDebugError::post("SbTri3f::intersect", "programming logic error 4\n");
      SoDebugError::post("-", "SbVec3f a1(%g, %g, %g);", a1[0], a1[1], a1[2]);
      SoDebugError::post("-", "SbVec3f b1(%g, %g, %g);", b1[0], b1[1], b1[2]);
      SoDebugError::post("-", "SbVec3f c1(%g, %g, %g);", c1[0], c1[1], c1[2]);
      SoDebugError::post("-", "SbVec3f a2(%g, %g, %g);", a2[0], a2[1], a2[2]);
      SoDebugError::post("-", "SbVec3f b2(%g, %g, %g);", b2[0], b2[1], b2[2]);
      SoDebugError::post("-", "SbVec3f c2(%g, %g, %g);", c2[0], c2[1], c2[2]);
      assert(0);
    }
    return FALSE;
  }

  // find end point of the four (the one furtest from origo would be an end point)
  // and the length of that line segment
  float distance, maxdistance;
  int vertex = 1;
  maxdistance = p11.sqrLength();
  distance = p12.sqrLength();
  if ( distance > maxdistance ) {
    vertex = 2;
    maxdistance = distance;
  }
  distance = p21.sqrLength();
  if ( distance > maxdistance ) {
    vertex = 3;
    maxdistance = distance;
  }
  distance = p22.sqrLength();
  if ( distance > maxdistance ) {
    vertex = 4;
    maxdistance = distance;
  }

  // check if a vertec from the other line segment is within the perimeter of the line
  SbVec3f p, e, p1, p2;
  switch ( vertex ) {
  case 1:
    p = p11; e = p12; p1 = p21; p2 = p22;
    break;
  case 2:
    p = p12; e = p11; p1 = p21; p2 = p22;
    break;
  case 3:
    p = p21; e = p22; p1 = p11; p2 = p12;
    break;
  case 4:
    p = p22; e = p21; p1 = p11; p2 = p12;
    break;
  default:
    if ( COIN_DEBUG )
      SoDebugError::post("SbTri3f::intersect", "programming logic error 5\n");
    assert(0);
  }
  float pedistance = (e - p).sqrLength();
  if ( pedistance > (p1-p).sqrLength() ) return TRUE;
  if ( pedistance > (p2-p).sqrLength() ) return TRUE;
  return FALSE;
}

SbBool
SbTri3f::intersect(const SbTri3f & t, float e) const
{
  if (e == 0.0f) return this->intersect(t);
  if (this->getDistance(t) <= e) return TRUE;
  return FALSE;
}

SbVec3f
SbTri3f::getNormal() const
{
  SbVec3f p[3];
  this->getValue(p[0], p[1], p[2]);
  SbPlane pl(p[0], p[1], p[2]);
  return pl.getNormal();
}

/*!
  Returns the distance from the given point to this triangle.
*/
float 
SbTri3f::getDistance(const SbVec3f & p) const
{
  float dist = FLT_MAX;
  SbVec3f thisp[3];
  this->getValue(thisp[0], thisp[1], thisp[2]);
  SbPlane pl(thisp[0], thisp[1], thisp[2]);

  SbVec3f intersect;
  SbVec3f n = this->getNormal();
  SbLine line(p, p+n);
  if (pl.intersect(line, intersect)) {
    int i;
    for (i=0;i<3;i++) {
      SbPlane edgepl(thisp[i], thisp[i]+n, thisp[(i+1)%3]);
      if (!edgepl.isInHalfSpace(intersect)) break;
    }
    if (i == 3) dist = fabs(pl.getDistance(p));
    else { // We didn't project inside triangle
      for (int j=0;j<3;j++) {
        float d = this->getDistance(p, thisp[j], thisp[(j+1)%3]);
	if (d < dist) dist = d;
      }
    }
  }
  else {
    assert(false);
  }
  return dist;
}

/*!
  Returns the distance from p to the line segment p1-p2.
*/
float 
SbTri3f::getDistance(const SbVec3f & p, 
                     const SbVec3f & p1, const SbVec3f & p2) const
{
  SbVec3f normal = p2 - p1;
  SbPlane pl(normal, p);
  SbPlane pl1(normal, p1);
  SbPlane pl2(-normal, p2);

  if (pl1.isInHalfSpace(p) && pl2.isInHalfSpace(p)) {
    SbLine line(p1, p2);
    return (line.getClosestPoint(p)-p).length();
  }
  else {
    float d1 = (p - p1).length();
    float d2 = (p - p2).length();
    return (d1<d2)?d1:d2;
  }
}

/*!
  Returns the minimum distance from this triangle to the given triangle.
*/
float 
SbTri3f::getDistance(const SbTri3f & t) const
{
  float dist = FLT_MAX;
  SbVec3f p[3];
  t.getValue(p[0], p[1], p[2]);
  for (int i=0;i<3;i++) {
    float d = this->getDistance(p[i]);
    if (d < dist) dist = d;
  }
  this->getValue(p[0], p[1], p[2]);
  for (i=0;i<3;i++) {
    float d = t.getDistance(p[i]);
    if (d < dist) dist = d;
  }

  return dist;
}

// *************************************************************************
