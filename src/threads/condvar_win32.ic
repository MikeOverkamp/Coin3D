/**************************************************************************\
 *
 *  This file is part of the Coin 3D visualization library.
 *  Copyright (C) 1998-2001 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 2 as
 *  published by the Free Software Foundation.  See the file LICENSE.GPL
 *  at the root directory of this source distribution for more details.
 *
 *  If you desire to use Coin with software that is incompatible
 *  licensewise with the GPL, and / or you would like to take
 *  advantage of the additional benefits with regard to our support
 *  services, please contact Systems in Motion about acquiring a Coin
 *  Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, 7030 Trondheim, NORWAY
 *  www.sim.no, support@sim.no, Voice: +47 22114160, Fax: +47 22207097
 *
\**************************************************************************/

/* This file should only be included from condvar.c */

static int
internal_struct_init(cc_condvar * condvar_struct)
{
  /* auto-reset, initially is non-signaled */
  condvar_struct->w32thread.eventhandle_one = CreateEvent(NULL, FALSE, FALSE, NULL);
  if (condvar_struct->w32thread.eventhandle_one == NULL) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_fprintf(stderr, "CreateEvent() error: %d, \"%s\"\n",
        err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }
  /* auto-reset, initially is non-signaled */
  condvar_struct->w32thread.eventhandle_all = CreateEvent(NULL, TRUE, FALSE, NULL);
  if (condvar_struct->w32thread.eventhandle_all == NULL) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_fprintf(stderr, "CreateEvent() error: %d, \"%s\"\n",
        err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }
  return CC_OK;
}

static int
internal_struct_clean(cc_condvar * condvar_struct)
{
  BOOL status;
  int ret = CC_OK;
  status = CloseHandle(condvar_struct->w32thread.eventhandle_one);
  if (status == FALSE) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_fprintf(stderr, "CloseHandle() error: %d, \"%s\"\n",
        err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    ret = CC_ERROR;
  }
  status = CloseHandle(condvar_struct->w32thread.eventhandle_all);
  if (status == FALSE) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_fprintf(stderr, "CloseHandle() error: %d, \"%s\"\n",
        err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    ret = CC_ERROR;
  }
  return ret;
}

static int
internal_wait(cc_condvar * condvar)
{
  DWORD status;
  HANDLE eventhandles[2];

  eventhandles[0] = condvar->w32thread.eventhandle_one;
  eventhandles[1] = condvar->w32thread.eventhandle_all;
  status = WaitForMultipleObjects(2, eventhandles, FALSE, INFINITE);
  if (status == WAIT_FAILED) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_fprintf(stderr, "WaitForMultipleObjects() error: %d, \"%s\"\n",
        err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }
  else if ((status != WAIT_OBJECT_0) && (status != WAIT_OBJECT_0+1) ) {
    if (COIN_DEBUG) {
      cc_fprintf(stderr, "WaitForSingleObject() - unknown return value: %d\n",
                 status);
    }
    return CC_ERROR;
  }
  return CC_OK;
}

static int
internal_timed_wait(cc_condvar * condvar, cc_time period)
{
  DWORD status;
  HANDLE eventhandles[2];

  eventhandles[0] = condvar->w32thread.eventhandle_one;
  eventhandles[1] = condvar->w32thread.eventhandle_all;
  status = WaitForMultipleObjects(2, eventhandles, FALSE, (DWORD)floor(period*1000.0f));
  if (status == WAIT_FAILED) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_fprintf(stderr, "WaitForMultipleObjects() error: %d, \"%s\"\n",
        err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }
  else if ((status == WAIT_OBJECT_0) || (status == WAIT_OBJECT_0+1)) {
    return CC_OK;
  }
  else if (status == WAIT_TIMEOUT) {
    return CC_TIMEOUT;
  }
  /* if we get here, there was an error */
  if (COIN_DEBUG) {
    cc_fprintf(stderr, "WaitForSingleObject() - unknown return value: %d\n",
               status);
  }
  return CC_ERROR;
}

static int
internal_wake_one(cc_condvar * condvar)
{
  BOOL status;

  status = PulseEvent(condvar->w32thread.eventhandle_one);
  /* the event is auto-reset */
  if (status == FALSE) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_fprintf(stderr, "SetEvent error: %d, \"%s\"\n",
        err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }
  return CC_OK;
}

static int
internal_wake_all(cc_condvar * condvar)
{
  BOOL status = PulseEvent(condvar->w32thread.eventhandle_all);
  /* event is manually-reset, but PulseEvent will reset when all
     waiting threads have been released */
  if (status == FALSE) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_fprintf(stderr, "SetEvent error: %d, \"%s\"\n",
        err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }
  return CC_OK;
}
