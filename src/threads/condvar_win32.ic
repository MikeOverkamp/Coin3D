/**************************************************************************\
 *
 *  This file is part of the Coin 3D visualization library.
 *  Copyright (C) 1998-2002 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  ("GPL") version 2 as published by the Free Software Foundation.
 *  See the file LICENSE.GPL at the root directory of this source
 *  distribution for additional information about the GNU GPL.
 *
 *  For using Coin with software that can not be combined with the GNU
 *  GPL, and for taking advantage of the additional benefits of our
 *  support services, please contact Systems in Motion about acquiring
 *  a Coin Professional Edition License.
 *
 *  See <URL:http://www.coin3d.org> for  more information.
 *
 *  Systems in Motion, Prof Brochs gate 6, 7030 Trondheim, NORWAY.
 *  <URL:http://www.sim.no>.
 *
\**************************************************************************/

/* This file should only be included from condvar.c */

#define EVENT_SIGNAL 0
#define EVENT_BROADCAST 1

#include <Inventor/C/base/basep.h>

/*
 * This implementation is based on the SetEvent (3.2) solution decribed at
 * http://www.cs.wustl.edu/~schmidt/win32-cv-1.html.
 */

static int
internal_condvar_struct_init(cc_condvar * condvar_struct)
{
  /* auto-reset, initially is non-signaled */
  condvar_struct->w32thread.eventhandle[EVENT_SIGNAL] =
    CreateEvent(NULL, FALSE, FALSE, NULL);
  if (condvar_struct->w32thread.eventhandle[EVENT_SIGNAL] == NULL) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_debugerror_post("internal_condvar_struct_init",
			 "CreateEvent() error: %d, \"%s\"\n",
			 err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }
  /* auto-reset, initially is non-signaled */
  condvar_struct->w32thread.eventhandle[EVENT_BROADCAST] =
    CreateEvent(NULL, TRUE, FALSE, NULL);
  if (condvar_struct->w32thread.eventhandle[EVENT_BROADCAST] == NULL) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_debugerror_post("internal_condvar_struct_init",
			 "CreateEvent() error: %d, \"%s\"\n",
			 err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }
  InitializeCriticalSection(&condvar_struct->w32thread.waiters_count_lock);
  condvar_struct->w32thread.waiters_count = 0;
  return CC_OK;
}

static int
internal_condvar_struct_clean(cc_condvar * condvar_struct)
{
  BOOL status;
  int ret = CC_OK;
  status = CloseHandle(condvar_struct->w32thread.eventhandle[EVENT_SIGNAL]);
  if (status == FALSE) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_debugerror_post("internal_condvar_struct_clean",
			 "CloseHandle() error: %d, \"%s\"\n",
			 err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    ret = CC_ERROR;
  }
  status = CloseHandle(condvar_struct->w32thread.eventhandle[EVENT_BROADCAST]);
  if (status == FALSE) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_debugerror_post("internal_condvar_struct_clean",
			 "CloseHandle() error: %d, \"%s\"\n",
			 err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    ret = CC_ERROR;
  }
  DeleteCriticalSection(&condvar_struct->w32thread.waiters_count_lock);
  return ret;
}

static int
internal_condvar_wait_common(cc_condvar * condvar, cc_mutex * mutex, DWORD period)
{
  int result;
  int last_waiter;

  EnterCriticalSection(&condvar->w32thread.waiters_count_lock);
  condvar->w32thread.waiters_count++;
  LeaveCriticalSection(&condvar->w32thread.waiters_count_lock);

  /* It's ok to release <mutex> here since Win32 manual-reset events
   * maintain state when used with <SetEvent>.  This avoids the "lost
   * wakeup" bug... */
  cc_mutex_unlock(mutex);

  result = WaitForMultipleObjects(2, condvar->w32thread.eventhandle, FALSE, period);

  EnterCriticalSection(&condvar->w32thread.waiters_count_lock);
  condvar->w32thread.waiters_count--;
  last_waiter =
    result == WAIT_OBJECT_0 + EVENT_BROADCAST &&
    condvar->w32thread.waiters_count == 0;
  LeaveCriticalSection(&condvar->w32thread.waiters_count_lock);
  /* Some thread called wake_all */
  if (last_waiter) {
    /* We're the last waiter to be notified or to stop waiting, so
     * reset the manual event. */
    ResetEvent(condvar->w32thread.eventhandle[EVENT_BROADCAST]);
  }

  /* relock the mutex before returning */
  cc_mutex_lock(mutex);

  if (result == WAIT_FAILED) {
    if (COIN_DEBUG) {
      DWORD err;
      char *errstr;
      err = GetLastError();
      errstr = cc_internal_w32_getlasterrorstring(err);
      cc_debugerror_post("internal_condvar_wait_common",
			 "WaitForMultipleObjects() error: %d, \"%s\"\n",
			 err, errstr);
      cc_internal_w32_freelasterrorstring(errstr);
    }
    return CC_ERROR;
  }

  return result == WAIT_TIMEOUT ? CC_TIMEOUT : CC_OK;
}

static int
internal_condvar_wait(cc_condvar * condvar, cc_mutex * mutex)
{
  return internal_condvar_wait_common(condvar, mutex, INFINITE);
}

static int
internal_condvar_timed_wait(cc_condvar * condvar, cc_mutex * mutex, cc_time period)
{
  return internal_condvar_wait_common(condvar, mutex, (DWORD)floor(period*1000.0f));
}

static int
internal_condvar_wake_one(cc_condvar * condvar)
{
  int have_waiters;
  EnterCriticalSection(&condvar->w32thread.waiters_count_lock);
  have_waiters = condvar->w32thread.waiters_count > 0;
  LeaveCriticalSection(&condvar->w32thread.waiters_count_lock);

  if (have_waiters) {
    SetEvent(condvar->w32thread.eventhandle[EVENT_SIGNAL]);
  }
  return CC_OK;
}

static int
internal_condvar_wake_all(cc_condvar * condvar)
{
  int have_waiters;
  EnterCriticalSection(&condvar->w32thread.waiters_count_lock);
  have_waiters = condvar->w32thread.waiters_count > 0;
  LeaveCriticalSection(&condvar->w32thread.waiters_count_lock);

  if (have_waiters) {
    SetEvent(condvar->w32thread.eventhandle[EVENT_BROADCAST]);
  }
  return CC_OK;
}

#undef EVENT_SIGNAL
#undef EVENT_BROADCAST
