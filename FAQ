
Frequently Asked Questions for Coin
===================================

Last Updated:
$Date$

For answers to common Open Inventor programming issues not covered in this
FAQ, take a look at the FAQs directory in the SoGuiExamples archive.

For answers to common qquestions regarding the SoQt library, see the FAQ
in the SoQt source archive.

For answers to common questions regarding licensing, see the FAQ.legal
file in the Coin source archive.

The most up-to-date version of this file can always be found at
http://source.coin3d.org/Coin/FAQ


Index
=====

1: Extensions and Ports
  Q1: Are there plans for making Coin multi-thread safe?

  Q2: Can Coin do multi-pipe rendering?

  Q3: Can I do volume rendering with Coin?

  Q4: Does Coin support VRML97?

  Q5: Is there an MS Visual C++ project I can use to build Coin?

  Q6: Is there a Coin port for Mac OS X/Darwin?

2: Common Problems
  Q1: <Node>::classTypeId != SoType::badType() && "You forgot init()"?

  Q2: Why doesn't it work properly to render the same scene graph in two
      different windows?

  Q3: Why does my Visual C++ program using Coin work for debug builds but
      not for release builds?

  Q4: I try to change the SoText2/SoText3 font, but nothing happens.
      Why, oh why?

  Q5: Where does the SoGuiExamples module install the programs?

  Q6: Why can't any of the transparency modes be perfect?

3: Other Hows and Whys
  Q1: Why is the .so-version 20 for Coin 1.0 and 40 for Coin 2.0?



Section 1. Extensions and Ports
===============================

Q1.1:   Are there plans for making Coin multi-thread safe?

A:      Coin will probably never be 100% thread safe, but in Coin 2.0 we've
        added support for thread safe rendering. This means that you
        can render a scene graph using many threads, at the same
        time. The application programmer is responsible for all thread
        synchronization though, but we've added many thread classes to
        make this easier for you (SbMutex, SbRWMutex, SbStorage,
        SbBarrier, ...).
       
Q1.2:   Can Coin do multi-pipe rendering?

A:      Yes, but you have to do some work. Coin can do thread-safe
        rendering traversals, but we haven't implemented a simple
        viewer that will set up the OpenGL contexts and handle the
        rendering for each context yet. We've done some internal
        testing with SGI's OpenGL Multipipe SDK, and we might release
        a viewer using that SDK.  Please contact us if you're
        interested in multi-pipe rendering.

Q1.3:   Can I do volume rendering with Coin?

A:      There are no volume rendering extensions for Coin yet.  Support for
        3D textures, which is a prerequisite for proper volume rendering
        support, was implemented for Coin 2.0.

        Exactly when fullblown volume rendering is going to be implemented
        is in the blue, but it is functionality we see a demand for, so we
        are certainly interested in adding support for it, but there are
        no concrete plans for putting resources on this currently.


Q1.4:   Does Coin support VRML97?

A:      Coin 1.* does not support VRML97.  Coin 2.0 and upwards supports it.
        We are not supporting 100% of the VRML97 standard yet, but most
        models will load and display correctly. The main missing features
        are URL loading (there are callbacks that makes it possible for the
        application programmer to fix this though), proper support for
        bindable nodes, and scripting (can also be supported through
        callbacks).


Q1.5:   Is there an MS Visual C++ project I can use to build Coin?

A:      Yes.  We have now developed a system that uses the Autoconf/Automake
        build system to auto-generate a Microsoft Developer Studio project
        and workspace file for building the Coin library.  This setup
        is included with the binary installer for Coin 2.0 and later.
        It will be backported to Coin 1.* and ported to the GUI libraries
        in a while.  You therefore no longer need Cygwin to compile Coin
        if you use the win32 binary installer packages.

        If you want to generate the .dsp file directly from the source
        repository yourself, see the file INSTALL about the --with-msvcdsp
        configure option.  For this you need Cygwin installed.


Q1.6:   Is there a Coin port for Mac OS X/Darwin?

A:      Coin configures and compiles on Mac OS X, but there is currently no
        SoMac library available.

        For a window binding, there are still at least three options:
        1) use Coin with GLUT, 2) manage the GL context manually, 3)
        use the port of the Qt multiplatform library -- see
        <URL:http://www.trolltech.com>.


Section 2. Common Problems
==========================

Q2.1:   <Node>::classTypeId != SoType::badType() && "You forgot init()"?

A:      If you get this assert, it means the run-time type system in
        Coin was not initialized at the time a <Node> object is constructed.

        This can happen for several reasons:
        - you haven't called SoDB::init() yet when you construct a node.
        - you have a global node that is constructed automatically on startup
          before main is run.
        - [VC++] you have linked multiple instances of the Coin library into
          your application or the Coin library and the application or some
          other library are using different C library instances.

        In the case of not calling SoDB::init(), it is clearly stated on
        page 36 of The Inventor Mentor that "SoDB::init() must be the first
        Inventor call you make.".

        "But this works with SGI Inventor", I hear you say...  Actually,
        that is just pure luck.  Try e.g. creating a new SoBlinker node,
        and you will see your application going down in flames.


Q2.2:   Why doesn't it work properly to render the same scene graph in two
        different windows?

A:      The reason is probably that the two windows do not share the same
        GL context, but the render actions are not set up with different
        cache contexts.  Use two different values with
        SoGLRenderAction::setCacheContext() for the two windows' render
        actions.  Example follows:

          for (int i=0; i < NR_VIEWERS; i++) {
            SoGLRenderAction * renderaction = window[i]->getGLRenderAction();
        #ifdef __COIN__
          /* In Coin, we have added an extension to SoGLCacheContextElement
             for getting a _guaranteed_ unique number for the cache contexts.
             That the original Inventor API is missing a function like this
             should be considered an ugly flaw in the design. */
            uint32_t uniqcc = SoGLCacheContextElement::getUniqueCacheContext();
        #else // SGI or TGS Inventor
          /* Use a "pseudo-random" number and cross your fingers that it's
             unique, since there's no decent method in the API from which
             the application programmer can get a unique cache context id. */
            uint32_t uniqcc = 19720408 + i;
        #endif // SGI / TGS Inventor
            renderaction->setCacheContext(uniqcc);
          }

        This is taken care of automatically by Systems in Motion's
        SoQt / SoGtk / SoXt / SoWin libraries, so you shouldn't have
        to worry about it unless you are making your own GUI binding
        to Coin from scratch.


Q2.3:   Why does my Visual C++ program using Coin work for debug builds but
        not for release builds?

A:      The MS Visual C++ compiler changes behaviour when you change between
        DEBUG and RELEASE mode.  Initialization of variables is one thing
        in particular you should look at - debug compilation will cause
        all variables to be initialized to zero, while they will have random
        values for release builds.

        There are of course other possible causes as well.


Q2.4:   I try to change the SoText2/SoText3 font, but nothing happens.
        Why, oh why?

A:      The font support is currently limited to a hardcoded font for both
        Text2 and Text3.  Better to have one font than none at all.

        Support for external fonts is in development.


Q2.5:   Where does the SoGuiExamples module install the programs?

A:      They are not installed.  The programs are just examples, and do not
        belong with the installed executables on a system.  They are built
        in the build dir, and are intended to be run from there.


Q2.6:   Why can't any of the transparency modes be perfect?

A:      (First of all, read the documentation on
        SoGLRenderAction::TransparencyMode.)

        Doing correct rendering of multiple transparent objects often
        fails because, to be 100% correct, all polygons needs to be
        rendered in sorted order, and none of the polygons can
        intersect with other polygons.

        Now, how expensive would it be to check for intersecting
        polygons and just split those into non-intersecting ones?  Why
        is that so hard that it's not done?

        It's not really that hard, but it's very difficult to do it
        fast.  It's basically a O(n^2) problem (n = number of
        triangles in the scene), since you for every triangle have to
        test if it intersects any of the other triangles.

        Of course it's possible to optimize this by using an oct tree
        structure or something, but in a dynamic scene graph you have
        to build/change this oct tree structure every frame, which can
        be quite expensive.  Also, rendering will be much slower,
        since you can no longer use the tight rendering loops we now
        use. The steps needed to do correct transparency rendering is:

          1. Generate and store all triangles, using SoCallbackAction.

          2. Clip all intersecting triangles, producing any number of
             new triangles.

          3. Sort all triangles on distance to projection plane.

          4. For each triangle
            4.1. set correct OpenGL rendering state (material, texture, etc)
            4.2. render triangle

        You also risk lots of expensive OpenGL state changes, since
        you might have to change texture/material for every triangle
        in 4.1. This is a very slow operation in OpenGL.

        All of the above steps can be done from application code, so
        it's not absolutely necessary to have this as a Coin feature.

        It /might/ be added as a feature of the library sometime in
        the future, as having the option of choosing correct but
        (possibly very) slow rendering over flawed transparency
        rendering would probably be worthwhile for many users.


Section 3. Other Hows and Whys
==============================

Q3.1:   Why is the .so-version 20 for Coin 1.0 and 40 for Coin 2.0?

A:      This was done to keep the artificial mapping we have constructed
        between the release version number and ABI interface version of Coin
        as simple as possible.  We have this mapping because we plan to
        do parallell development of Coin 1.0 and Coin 2.0 at the same time
        because Coin 1.0 has special status as the Open Inventor 2.1
        compatibility release.

        Keep in mind that .so-version numbers and release version numbers
        really do not have anything to do with each other in the first place.

        When you release a new major version of a library, you usually
        break compatibility with earlier versions of the library.  When you
        change the API/ABI of a library, you increment the interface number
        to indicate that the library has a new interface.  Since we want to
        continue development of Coin 1.0 after Coin 2.0 is released, we need
        to reserve space for future Coin 1.x releases, and set the Coin 2.0
        interface number after the reserved space.  We decided 20 interface-
        numbers would suffice for each major version of the Coin library,
        and the simplest equation for finding the interface number became
        major*20+minor.

        Incidentally, a lot of platforms (Linux included) calculate the
        .so-number by taking the interface number and subtracting the age,
        and the age is the same as the minor release version number for
        Coin.  This will make the .so-number stay at 20 for the whole 1.x
        series and similarly stay at 40 for the whole 2.x series, which of
        course looks silly, but that's the way it is.

        See also the Libtool manual, section about Versioning.  It's the
        same system, except that we have added reserved space in our scheme.

--
